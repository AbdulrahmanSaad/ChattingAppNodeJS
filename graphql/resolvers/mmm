const bcrypt = require('bcrypt')
const jwt = require('jsonwebtoken')
const Message = require('../../Models/Event')
const User = require('../../Models/User')

module.exports = {
    Query: {
        messages: () => {
            return Message.find().populate('creator')
                .then(messages => {
                    return messages.map(message => {
                        return {
                            ...message._doc,
                        }
                    })
                })
        },
        users: () => {
            return User.find().populate('sentMessages')
                .then(res => {
                    return res
                }).catch(err => { console.log(err) })
        },
    },
    Mutation: {
        sendMessage: (args, req) => {
            if (!req.isAuth) {
                throw new Error("Unauthenticated")
            }
            const {
                text,
                sender
            } = args.sendMessageInput

            const message = new Message({
                text,
                sender: req.userId
            })
            let sentMessage
            return message
                .save()
                .then((res) => {
                    sentMessage = {
                        ...res._doc,
                    }
                    res
                    return User.findById(sender)
                })
                .then(user => {
                    user.sentMessages.push(event)
                    return user.save()
                })
                .catch(err => { console.log(err) })
                .then(result => {
                    return sentMessage
                })
        },
        createUser: (args) => {
            const {
                email,
                password
            } = args.createUserInput

            return User.findOne({ email }).then(user => {
                if (user) {
                    throw new Error("Email already in use")
                } else {
                    return bcrypt.hash(password, 12).then((result) => {
                        const user = new User({
                            email,
                            password: result
                        })
                        return user.save().then(res => { return res }).catch(err => { console.log(err) })
                    })
                }
            })
        },
        login: (args) => {
            const {
                email,
                password
            } = args.auth

            return User.findOne({ email })
                .then((user) => {
                    if (user) {
                        return bcrypt.compare(password, user.password)
                            .then(same => {
                                if (!same) {
                                    throw new Error("Not matching password!")
                                }
                                else {
                                    let token = jwt.sign({
                                        email,
                                        userId: user._id
                                    }, "This is the JWT Secret")
                                    const authData = {
                                        _id: user._id,
                                        token
                                    }
                                    return authData
                                }
                            }).then(res => {
                                return res
                            }).catch(err => console.log(err))
                    }
                })
        }
    }
}





module.exports = `
        type Message {
            _id: ID!
            text: String!
        }

        type User {
            _id: ID!
            email: String!
            password: String
            sentMessages: [Event!]
        }

        type AuthData {
            _id: ID!
            token: String!
        }

        type Query {
            messages: [Event!]!
            users: [User!]!
        }
        
        input MessageInput {
            text: String!
            sender: ID!
        }

        input UserInput {
            email: String!
            password: String!
        }

        type Mutation {
            sendMessage(sendMessageInput: MessageInput): Message
            createUser(createUserInput: UserInput): User
            login(auth: UserInput): AuthData
        }

        schema {
            query: Query
            mutation: Mutation
        }
    `